package ch.kanti_wohlen.klassenkasse.framework;

import java.util.Map;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.NonNullByDefault;

import ch.kanti_wohlen.klassenkasse.util.MonetaryValue;

/**
 * Represents a user, which can be a student, a teacher or an administrator.
 * <p>
 * A {@code User} is uniquely identifiable by its ID or its E-Mail address.
 * Every user has a {@link Role} assigned to it and must be in a {@link StudentClass}.
 * </p>
 * <p>
 * Administrators and the like shall be in the {@link StudentClass} with the ID 0,
 * which will not be displayed.
 * </p>
 * 
 * @author Roger Baumgartner
 */
public class User implements LocallyIdentifiable<Integer> {

	public static enum NamingMode {
		FIRST_NAME_FIRST,
		LAST_NAME_FIRST
	}

	private final int id;

	private int classId;
	private int roleId;
	private String firstName;
	private String lastName;
	private String eMailAddress;
	private MonetaryValue balance;

	/**
	 * Creates a new {@code User} with a new ID generated by a {@link Host}.
	 * 
	 * @param host
	 *            the host which is used to generate a new {@code User} ID,
	 *            cannot be null
	 * @param classId
	 *            the ID of the {@link StudentClass} this {@code User} is in
	 * @param roleId
	 *            the ID of the {@link Role} this {@code User} is in
	 * @param firstName
	 *            the first name, cannot be null or empty
	 * @param lastName
	 *            the last name, cannot be null or empty
	 * @param eMail
	 *            the e-mail address, cannot be null or empty
	 */
	@NonNullByDefault
	public User(Host host, int classId, int roleId, String firstName, String lastName, String eMail) {
		id = host.getIdProvider().generateUserId();

		setStudentClass(classId);
		setRole(roleId);
		setFirstName(firstName);
		setLastName(lastName);
		setEmailAddress(eMail);
		balance = MonetaryValue.ZERO;
	}

	/**
	 * Creates a new {@code User} with a given ID.
	 * <p>
	 * Use this constructor when loading a {@code User} from stored data or similar.
	 * </p>
	 * 
	 * @param id
	 *            the local ID to be set
	 * @param classId
	 *            the ID of the {@link StudentClass} this {@code User} is in
	 * @param roleId
	 *            the ID of the {@link Role} this {@code User} is in
	 * @param firstName
	 *            the first name, cannot be null or empty
	 * @param lastName
	 *            the last name, cannot be null or empty
	 * @param eMail
	 *            the e-mail address, cannot be null or empty
	 * @param value
	 *            the cached balance of all {@link Payment}s
	 */
	@NonNullByDefault
	public User(int id, int classId, int roleId, String firstName, String lastName, String eMail, MonetaryValue value) {
		this.id = id;

		setStudentClass(classId);
		setRole(roleId);
		setFirstName(firstName);
		setLastName(lastName);
		setEmailAddress(eMail);
		balance = value;
	}

	/**
	 * Gets the ID of this {@code User}, local to the current system.
	 * 
	 * @return the local ID
	 */
	@SuppressWarnings("null")
	@Override
	public Integer getLocalId() {
		return id;
	}

	/**
	 * Gets the ID of this {@code User}'s {@link StudentClass}.
	 * 
	 * @return the {@code StudentClass} ID
	 * 
	 * @see #getStudentClass(Host)
	 */
	public int getStudentClassId() {
		return classId;
	}

	/**
	 * Gets the {@link StudentClass} that is associated to the stored class ID.
	 * 
	 * @param host
	 *            the {@link Host} used to look up the {@code StudentClass}
	 * @return the {@code User}'s {@code StudentClass}
	 * 
	 * @see #getStudentClassId()
	 */
	public StudentClass getStudentClass(@NonNull Host host) {
		StudentClass studentClass = host.getClassById(classId);
		if (studentClass == null) {
			throw new IllegalStateException("The host does not contain this User's StudentClass");
		}
		return studentClass;
	}

	/**
	 * Sets the stored {@link StudentClass} ID by looking up the
	 * {@linkplain StudentClass#getLocalId() localID} of a {@code StudentClass}.
	 * 
	 * @param newStudentClass
	 *            the {@code StudentClass}, cannot be null
	 * 
	 * @see #setStudentClass(int)
	 */
	public void setStudentClass(@NonNull StudentClass newStudentClass) {
		classId = newStudentClass.getLocalId();
	}

	/**
	 * Sets the stored {@link StudentClass} ID.
	 * The ID set here is not checked for validity.
	 * 
	 * @param newClassId
	 *            the ID of a valid {@code StudentClass}
	 * 
	 * @see #setStudentClass(StudentClass)
	 */
	public void setStudentClass(int newClassId) {
		classId = newClassId;
	}

	/**
	 * Gets the ID of this {@code User}'s {@link Role}.
	 * 
	 * @return the {@code Role} ID
	 * 
	 * @see #getRole(Host)
	 */
	public int getRoleId() {
		return roleId;
	}

	/**
	 * Gets the {@link Role} that is associated to the stored role ID.
	 * 
	 * @param host
	 *            the {@link Host} used to look up the {@code Role}
	 * @return the {@code User}'s {@code Role}
	 * 
	 * @see #getRoleId()
	 */
	public Role getRole(@NonNull Host host) {
		Role role = host.getRoleById(roleId);
		if (role == null) {
			throw new IllegalStateException("The host does not contain this User's StudentClass");
		}
		return role;
	}

	/**
	 * Sets the stored {@link Role} ID by looking up the {@linkplain Role#getLocalId() localID} of a {@code Role}.
	 * 
	 * @param newRole
	 *            the {@code Role}, cannot be null
	 * 
	 * @see #setRole(int)
	 */
	public void setRole(@NonNull Role newRole) {
		roleId = newRole.getLocalId();
	}

	/**
	 * Sets the stored {@link Role} ID.
	 * The ID set here is not checked for validity.
	 * 
	 * @param newRoleId
	 *            the ID of a valid {@code Role}
	 * 
	 * @see #setRole(Role)
	 */
	public void setRole(int newRoleId) {
		roleId = newRoleId;
	}

	/**
	 * Gets the first name of this {@code User}
	 * 
	 * @return the first name
	 */
	public String getFirstName() {
		return firstName;
	}

	/**
	 * Sets the first name of this {@code User}
	 * 
	 * @param newFirstName
	 *            the first name, cannot be null or empty
	 * @throws IllegalArgumentException
	 *             if the first name is empty
	 */
	public void setFirstName(@NonNull String newFirstName) {
		if (newFirstName.isEmpty()) throw new IllegalArgumentException("Empty first name.");
		firstName = newFirstName;
	}

	/**
	 * Gets the last name of this {@code User}
	 * 
	 * @return the last name
	 */
	public String getLastName() {
		return lastName;
	}

	/**
	 * Sets the last name of this {@code User}
	 * 
	 * @param newLastName
	 *            the last name, cannot be null or empty
	 * @throws IllegalArgumentException
	 *             if the last name is empty
	 */
	public void setLastName(@NonNull String newLastName) {
		if (newLastName.isEmpty()) throw new IllegalArgumentException("Empty last name.");
		lastName = newLastName;
	}

	/**
	 * Gets the {@code User}'s full name, using the first-name-first format.
	 * 
	 * @return the full name of the {@code User}, consisting of the first name
	 *         and
	 *         the last name.
	 * 
	 * @see NamingMode#FIRST_NAME_FIRST
	 * @see #getFullName(NamingMode)
	 */
	public String getFullName() {
		return getFullName(NamingMode.FIRST_NAME_FIRST);
	}

	/**
	 * Gets the {@code User}'s full name, using the formatting given by a {@link NamingMode}.
	 * 
	 * @param namingMode
	 *            the {@code NamingMode} to be used when creating the full name.
	 * @return the full name of the {@code User}, consisting of the first name
	 *         and
	 *         the last name.
	 * 
	 * @see NamingMode
	 */
	public String getFullName(@NonNull NamingMode namingMode) {
		switch (namingMode) {
		case FIRST_NAME_FIRST:
			return firstName + " " + lastName;
		case LAST_NAME_FIRST:
			return lastName + ", " + firstName;
		default:
			throw new IllegalArgumentException("Illegal naming mode parameter.");
		}
	}

	/**
	 * Gets this {@code User}'s unique E-Mail address.
	 * 
	 * @return this User's E-Mail address. Will not be null.
	 */
	public String getEMailAddress() {
		return eMailAddress;
	}

	/**
	 * Sets a new E-Mail address for this {@code User}.
	 * <p>
	 * Please note that the E-Mail address should be unique. However, this method does not check if it really is unique.
	 * </p>
	 * 
	 * @param newEMailAddress
	 *            the new E-Mail address, cannot be null or empty
	 * @throws IllegalArgumentException
	 *             if the new E-Mail address is empty
	 */
	public void setEmailAddress(@NonNull String newEMailAddress) {
		if (newEMailAddress.isEmpty()) {
			throw new IllegalArgumentException("E-Mail address cannot be an empty String.");
		}
		eMailAddress = newEMailAddress;
	}

	/**
	 * Gets the last calculated balance of this {@code User}.
	 * <p>
	 * After adding or altering payments, this value may be incorrect. To update the balance, use
	 * {@link #recalculateBalance(Host, boolean)}
	 * </p>
	 * 
	 * @return the cached balance
	 */
	public MonetaryValue getBalance() {
		return balance;
	}

	/**
	 * Recalculates this {@code User}'s balance by adding up the payment values.
	 * 
	 * @param host
	 *            the host from which the {@link Payment}s are looked up
	 * @param updateClass
	 *            whether the class balance should be updated. Use {@code false} for bulk updates
	 * @return the calculated balance
	 */
	public MonetaryValue recalculateBalance(@NonNull Host host, boolean updateClass) {
		Map<Integer, Payment> payments = host.getPaymentsByUser(id);

		MonetaryValue result = new MonetaryValue(0);
		for (Payment payment : payments.values()) {
			result = result.add(payment.getValue());
		}
		balance = result;

		if (updateClass) {
			getStudentClass(host).recalculateBalance(host);
		}

		return result;
	}
}
